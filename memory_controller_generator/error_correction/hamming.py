import itertools
from typing import Optional

import numpy as np
from amaranth import *

from . import GenericCode, GenericErrorCalculator
from ..util.matrix import generator_matrix_from_parity_check_matrix


class HammingCode(GenericCode):
    """
    Implementation of a standard Hamming code (SEC).

    This class implements the simplest standard Hamming code. The parity-check matrix of this code is generated by
    filling the columns with the binary representation of increasing integers starting from one. This code is only
    able to detect and correct a single error.
    """

    def __init__(self, data_bits: int) -> None:
        # Determine the number of parity bits required for the specified number of data bits
        parity_bits = 0
        for m in itertools.count():
            if 2 ** m - m - 1 >= data_bits:
                parity_bits = m
                break

        super().__init__(data_bits=data_bits, parity_bits=parity_bits)

        # Add the list of correctable errors
        for i in range(self.total_bits):
            self.correctable_errors.append((i,))

    def generate_matrices(self, timeout: Optional[float] = None) -> None:
        self.parity_check_matrix = np.zeros((self.parity_bits, self.total_bits), dtype=int)

        # Set the columns of the parity-check matrix to increasing binary values
        for col_idx, col in enumerate(self.parity_check_matrix.T):
            for bit in range(self.parity_bits):
                col[bit] = 1 if (col_idx + 1) & (1 << bit) else 0

        # Create the generator matrix from the parity-check matrix
        self.generator_matrix = generator_matrix_from_parity_check_matrix(self.parity_check_matrix)


class ExtendedHammingCode(GenericCode):
    """
    Implementation of an extended Hamming code (SEC-DED).

    This class implements the extended Hamming code, which adds a parity-check bit to detect two-bit errors. This is
    done by creating the parity-check matrix similar to the normal Hamming code, however in this case the last column
    is left all zeros, and the last row is filled with ones. This code is able to correct single bit errors and
    detect double bit errors.
    """

    def __init__(self, data_bits: int) -> None:
        # Calculate the number of parity bits with the same method as the Hamming code, but add one for the extra
        # parity bit.
        parity_bits = 0
        for m in itertools.count():
            if 2 ** m - m - 1 >= data_bits:
                parity_bits = m
                break
        parity_bits += 1

        super().__init__(data_bits=data_bits, parity_bits=parity_bits)

        # Add the list of correctable errors
        for i in range(self.total_bits):
            self.correctable_errors.append((i,))

        # Add the list of detectable errors
        for i in range(self.total_bits):
            for j in range(i + 1, self.total_bits):
                self.detectable_errors.append((i, j))

    def generate_matrices(self, timeout: Optional[float] = None) -> None:
        self.parity_check_matrix = np.zeros((self.parity_bits, self.total_bits), dtype=int)

        # Set the columns of the parity-check matrix to increasing binary values
        # For the extended hamming code we ignore the last row and column
        for col_idx, col in enumerate(self.parity_check_matrix.T[:-1]):
            for bit in range(self.parity_bits - 1):
                col[bit] = 1 if (col_idx + 1) & (1 << bit) else 0

        # Fill the bottom row with ones
        self.parity_check_matrix[-1] = np.ones((self.total_bits,))

        # Create the generator matrix from the parity-check matrix
        self.generator_matrix = generator_matrix_from_parity_check_matrix(self.parity_check_matrix)

    def error_calculator(self) -> "ExtendedHammingErrorCalculator":
        return ExtendedHammingErrorCalculator(self)


class ExtendedHammingErrorCalculator(GenericErrorCalculator):
    """
    Implementation of the error calculation for extended Hamming codes.

    This implementation still calculates the occurrence of an error by check for a non-zero syndrome. However,
    uncorrectable errors can be detected by simply checking if there was an error, and the last syndrome bit is zero.
    """

    def elaborate(self, platform) -> Module:
        """Elaborate the module implementation"""
        m = Module()
        m.d.comb += [
            self.error.eq(self.syndrome != 0),
            self.uncorrectable_error.eq(self.error & (self.syndrome[-1] == 0)),
        ]
        return m
