import itertools
from typing import Optional

import numpy as np

from . import GenericCode
from .matrix_util import generator_matrix_from_parity_check_matrix


class HammingCode(GenericCode):
    """
    Implementation of a standard Hamming code (SEC).

    This class implements the simplest standard Hamming code. The parity-check matrix of this code is generated by
    filling the columns with the binary representation of increasing integers starting from one. This code is only
    able to detect and correct a single error.
    """

    def __init__(self, data_bits: int):
        # Determine the number of parity bits required for the specified number of data bits
        parity_bits = 0
        for m in itertools.count():
            if 2 ** m - m - 1 >= data_bits:
                parity_bits = m
                break

        super().__init__(data_bits=data_bits, parity_bits=parity_bits)

    def generate_matrices(self, timeout: Optional[float] = None):
        self.parity_check_matrix = np.zeros((self.parity_bits, self.total_bits), dtype=np.int)

        # Set the columns of the parity-check matrix to increasing binary values
        for col_idx, col in enumerate(self.parity_check_matrix.T):
            for bit in range(self.parity_bits):
                col[bit] = 1 if (col_idx + 1) & (1 << bit) else 0

        # Create the generator matrix from the parity-check matrix
        self.generator_matrix = generator_matrix_from_parity_check_matrix(self.parity_check_matrix)

        # Add the list of correctable errors
        for i in range(self.total_bits):
            self.correctable_errors.append((i,))


class ExtendedHammingCode(HammingCode):
    """
    Implementation of an extended Hamming code (SEC-DED).

    This class implements the extended Hamming code, which adds a parity-check bit to detect two-bit errors. This is
    done by creating the parity-check matrix similar to the normal Hamming code, however in this case the last column
    is left all zeros, and the last row is filled with ones. This code is able to correct single bit errors and
    detect double bit errors.
    """

    def __init__(self, data_bits: int):
        # Inherit the number of parity bits from the Hamming code, but increment by one, as we are adding a single
        # over-all parity check
        super().__init__(data_bits=data_bits)
        self.parity_bits += 1

    def generate_matrices(self, timeout: Optional[float] = None):
        self.parity_check_matrix = np.zeros((self.parity_bits, self.total_bits), dtype=np.int)

        # Set the columns of the parity-check matrix to increasing binary values
        # For the extended hamming code we ignore the last row and column
        for col_idx, col in enumerate(self.parity_check_matrix.T[:-1]):
            for bit in range(self.parity_bits - 1):
                col[bit] = 1 if (col_idx + 1) & (1 << bit) else 0

        # Fill the bottom row with ones
        self.parity_check_matrix[-1] = np.ones((self.total_bits,))

        # Create the generator matrix from the parity-check matrix
        self.generator_matrix = generator_matrix_from_parity_check_matrix(self.parity_check_matrix)

        # Add the list of correctable errors
        for i in range(self.total_bits):
            self.correctable_errors.append((i,))
